/* This file borrowed from openstartracker in its entirety. I decided
 * it was a little too indecipherable for me to mess with it in the
 * short term. --Juno
 *
 * FIXME: In the short term, ought to convert these structs to
 *        namespaces without static members, since this is actually
 *        how they're used. --Juno
 */

#ifndef KDHASH_HPP
#define KDHASH_HPP

#include "types.hpp"

/** @brief multidimensional hash function based on morton codes
 * 
 * The magic numbers were generated by doc/gen_interleave.py
 *
 * If we ever need to implement decoding, useful info can be found here:
 * https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
 * (basically just do everything backwards)
 * 
 */
struct kdhash_2f {
#define DIAM 0xffffffff
#define R_IN (DIAM / 2)
#define R_OUT (R_IN + 1)
#define INTERLEAVE(X)				\
  if (X > DIAM) X = DIAM;				\
  if (X < 0) X = 0;					\
  X = (X | X << 16) & 0xffff0000ffff;			\
  X = (X | X << 8) & 0xff00ff00ff00ff;			\
  X = (X | X << 4) & 0xf0f0f0f0f0f0f0f;			\
  X = (X | X << 2) & 0x3333333333333333;		\
  X = (X | X << 1) & 0x5555555555555555;
	
  /** @brief hash function which interleaves values so that nearby
   **        coordinates will have nearby hashes this approach also also
   **        allows you to truncate the hash when less precision is needed
   */
  static inline hash_t hash(const float x0, const float x1){
    int64_t h0 = R_OUT * (x0 + 1.0);
    int64_t h1 = R_OUT * (x1 + 1.0);
    INTERLEAVE(h0);
    INTERLEAVE(h1);
    return h1 << 1 | h0;
  }
	
  /** @brief returns the number of bits we need to truncate in order
   **        to search a specified range
   */
  static inline uint8_t bin_size(const float r) {
    int64_t h = R_OUT * r;
    if (h > R_IN) h = R_IN;
    if (h < 0) h = 0;
    uint8_t sz = 0;
    for (; h; h >>= 1) sz += 1;
    return sz;
  }
  
  /** @brief returns a mask which can be used to clamp the hash to a
   **        specified precision
   **
   * @param r  mask a range of this size, rounded up to the nearest power of two
   */
  static inline hash_t mask(const float r) {
    hash_t mask = -1;
    return mask << 2 * bin_size(r);
  }
	
  /** @brief As before, but allows independent ranges for the different parameters 
   */
  static inline hash_t mask(const float r0,const float r1) {
    int64_t h0 = R_OUT >> bin_size(r0);
    int64_t h1 = R_OUT >> bin_size(r1);
    INTERLEAVE(h0);
    INTERLEAVE(h1);
    return h1 << 1 | h0;
  }
#undef INTERLEAVE
#undef R_OUT
#undef R_IN
#undef DIAM
};

struct kdhash_3f {
#define DIAM 0x1fffff
#define R_IN (DIAM/2)
#define R_OUT (R_IN+1)
#define INTERLEAVE(X)				\
  if (X > DIAM) X = DIAM;				\
  if (X < 0) X = 0;					\
  X = (X | X << 32) & 0x001f00000000ffff;		\
  X = (X | X << 16) & 0x001f0000ff0000ff;		\
  X = (X | X << 8) & 0x100f00f00f00f00f;		\
  X = (X | X << 4) & 0x10c30c30c30c30c3;		\
  X = (X | X << 2) & 0x1249249249249249;

  ///See kdhash_2f::hash
  static inline hash_t hash(const float x0, const float x1, const float x2){
    int64_t h0 = R_OUT * (x0 + 1.0);
    int64_t h1 = R_OUT * (x1 + 1.0);
    int64_t h2 = R_OUT * (x2 + 1.0);
    INTERLEAVE(h0);
    INTERLEAVE(h1);
    INTERLEAVE(h2);
    return h2 << 2 | h1 << 1 | h0;
  }
  
  ///See kdhash_2f::bin_size
  static inline uint8_t bin_size(const float radians) {
    int64_t h = R_OUT * radians;
    if (h > R_IN) h = R_IN;
    if (h < 0) h = 0;
    uint8_t sz = 0;
    for (; h; h >>= 1) sz += 1;
    return sz;
  }
  
  ///See kdhash_2f::mask
  static inline hash_t mask(const float radians) {
    hash_t mask = -1;
    return mask << 3 * bin_size(radians);
  }
	
  ///See kdhash_2f::mask
  static inline hash_t mask(const float r0,const float r1,const float r2){
    int64_t h0 = R_OUT >> bin_size(r0);
    int64_t h1 = R_OUT >> bin_size(r1);
    int64_t h2 = R_OUT >> bin_size(r2);
    INTERLEAVE(h0);
    INTERLEAVE(h1);
    INTERLEAVE(h2);
    return h2 << 2 | h1 << 1 | h0;
  }
#undef INTERLEAVE
#undef R_OUT
#undef R_IN
#undef DIAM
};

struct kdhash_4f {
#define DIAM 0xfffff
#define R_IN (DIAM/2)
#define R_OUT (R_IN+1)
#define INTERLEAVE(X)				\
  if (X > DIAM) X = DIAM;				\
  if (X < 0) X = 0;					\
  X = (X | X << 32) & 0xf800000007ff;			\
  X = (X | X << 16) & 0xf80007c0003f;			\
  X = (X | X << 8) & 0xc0380700c03807;			\
  X = (X | X << 4) & 0x843084308430843;			\
  X = (X | X << 2) & 0x909090909090909;			\
  X = (X | X << 1) & 0x1111111111111111;
  
  ///See kdhash_2f::hash
  static inline hash_t hash(const float x0,
			      const float x1,
			      const float x2,
			      const float x3) {
    int64_t h0 = R_OUT * (x0 + 1.0);
    int64_t h1 = R_OUT * (x1 + 1.0);
    int64_t h2 = R_OUT * (x2 + 1.0);
    int64_t h3 = R_OUT * (x3 + 1.0);
    INTERLEAVE(h0);
    INTERLEAVE(h1);
    INTERLEAVE(h2);
    INTERLEAVE(h3);
    return h3 << 3 | h2 << 2 | h1 << 1 | h0;
  }

  ///See kdhash_2f::bin_size
  static inline uint8_t bin_size(const float radians) {
    int64_t h = R_OUT * radians;
    if (h > R_IN) h = R_IN;
    if (h < 0) h = 0;
    uint8_t sz = 0;
    for (; h; h >>= 1) sz += 1;
    return sz;
  }
  
  ///See kdhash_2f::mask
  static inline hash_t mask(const float radians) {
    hash_t mask =- 1;
    return mask << 4 * bin_size(radians);
  }

  ///See kdhash_2f::mask
  static inline hash_t mask(const float r0, const float r1, const float r2, const float r3) {
    int64_t h0 = R_OUT >> bin_size(r0);
    int64_t h1 = R_OUT >> bin_size(r1);
    int64_t h2 = R_OUT >> bin_size(r2);
    int64_t h3 = R_OUT >> bin_size(r3);
    INTERLEAVE(h0);
    INTERLEAVE(h1);
    INTERLEAVE(h2);
    INTERLEAVE(h3);
    return h0 << 3 | h1 << 2 | h2 << 1 | h3;
  }
#undef INTERLEAVE
#undef R_OUT
#undef R_IN
#undef DIAM
};
#endif
